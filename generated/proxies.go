// Autogenerated by github.com/snonky/pocketbase-gogen. Do not edit.
package generated

import (
	"github.com/pocketbase/pocketbase/core"
	"github.com/pocketbase/pocketbase/tools/types"
)

type Users struct {
	core.BaseRecordProxy
}

func (p *Users) Name() string {
	return p.GetString("name")
}

func (p *Users) SetName(name string) {
	p.Set("name", name)
}

func (p *Users) Avatar() string {
	return p.GetString("avatar")
}

func (p *Users) SetAvatar(avatar string) {
	p.Set("avatar", avatar)
}

func (p *Users) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Users) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Users) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Users) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type PlayingLevel struct {
	core.BaseRecordProxy
}

func (p *PlayingLevel) Name() string {
	return p.GetString("name")
}

func (p *PlayingLevel) SetName(name string) {
	p.Set("name", name)
}

func (p *PlayingLevel) Index() float64 {
	return p.GetFloat("index")
}

func (p *PlayingLevel) SetIndex(index float64) {
	p.Set("index", index)
}

func (p *PlayingLevel) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *PlayingLevel) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *PlayingLevel) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *PlayingLevel) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type Club struct {
	core.BaseRecordProxy
}

func (p *Club) Name() string {
	return p.GetString("name")
}

func (p *Club) SetName(name string) {
	p.Set("name", name)
}

func (p *Club) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Club) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Club) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Club) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type PlayerStatus int

const (
	NotAttending PlayerStatus = iota
	Attending
	Injured
	Forfeited
	Disqualified
)

var zzPlayerStatusSelectNameMap = map[string]PlayerStatus{"notAttending": 0, "attending": 1, "injured": 2, "forfeited": 3, "disqualified": 4}
var zzPlayerStatusSelectIotaMap = map[PlayerStatus]string{0: "notAttending", 1: "attending", 2: "injured", 3: "forfeited", 4: "disqualified"}

type Player struct {
	core.BaseRecordProxy
}

func (p *Player) FirstName() string {
	return p.GetString("firstName")
}

func (p *Player) SetFirstName(firstName string) {
	p.Set("firstName", firstName)
}

func (p *Player) LastName() string {
	return p.GetString("lastName")
}

func (p *Player) SetLastName(lastName string) {
	p.Set("lastName", lastName)
}

func (p *Player) Notes() string {
	return p.GetString("notes")
}

func (p *Player) SetNotes(notes string) {
	p.Set("notes", notes)
}

func (p *Player) Status() PlayerStatus {
	option := p.GetString("status")
	i, ok := zzPlayerStatusSelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *Player) SetStatus(status PlayerStatus) {
	i, ok := zzPlayerStatusSelectIotaMap[status]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("status", i)
}

func (p *Player) Club() *Club {
	var proxy *Club
	if rel := p.ExpandedOne("club"); rel != nil {
		proxy = &Club{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Player) SetClub(club *Club) {
	e := p.Expand()
	e["club"] = club.Record
	p.SetExpand(e)
}

func (p *Player) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Player) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Player) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Player) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type GenderCategory int

const (
	Female GenderCategory = iota
	Male
	Mixed
	Any
)

var zzGenderCategorySelectNameMap = map[string]GenderCategory{"female": 0, "male": 1, "mixed": 2, "any": 3}
var zzGenderCategorySelectIotaMap = map[GenderCategory]string{0: "female", 1: "male", 2: "mixed", 3: "any"}

type Competition struct {
	core.BaseRecordProxy
}

func (p *Competition) TeamSize() float64 {
	return p.GetFloat("teamSize")
}

func (p *Competition) SetTeamSize(teamSize float64) {
	p.Set("teamSize", teamSize)
}

func (p *Competition) GenderCategory() GenderCategory {
	option := p.GetString("genderCategory")
	i, ok := zzGenderCategorySelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *Competition) SetGenderCategory(genderCategory GenderCategory) {
	i, ok := zzGenderCategorySelectIotaMap[genderCategory]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("genderCategory", i)
}

func (p *Competition) AgeGroup() *AgeGroup {
	var proxy *AgeGroup
	if rel := p.ExpandedOne("ageGroup"); rel != nil {
		proxy = &AgeGroup{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Competition) SetAgeGroup(ageGroup *AgeGroup) {
	e := p.Expand()
	e["ageGroup"] = ageGroup.Record
	p.SetExpand(e)
}

func (p *Competition) PlayingLevel() *PlayingLevel {
	var proxy *PlayingLevel
	if rel := p.ExpandedOne("playingLevel"); rel != nil {
		proxy = &PlayingLevel{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Competition) SetPlayingLevel(playingLevel *PlayingLevel) {
	e := p.Expand()
	e["playingLevel"] = playingLevel.Record
	p.SetExpand(e)
}

func (p *Competition) Registrations() []*Team {
	rels := p.ExpandedAll("registrations")
	proxies := make([]*Team, len(rels))
	for i := range len(rels) {
		proxies[i] = &Team{}
		proxies[i].Record = rels[i]
	}
	return proxies
}

func (p *Competition) SetRegistrations(registrations []*Team) {
	records := make([]*core.Record, len(registrations))
	for i, r := range registrations {
		records[i] = r.Record
	}
	e := p.Expand()
	e["registrations"] = records
	p.SetExpand(e)
}

func (p *Competition) TournamentModeSettings() *TournamentModeSettings {
	var proxy *TournamentModeSettings
	if rel := p.ExpandedOne("tournamentModeSettings"); rel != nil {
		proxy = &TournamentModeSettings{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Competition) SetTournamentModeSettings(tournamentModeSettings *TournamentModeSettings) {
	e := p.Expand()
	e["tournamentModeSettings"] = tournamentModeSettings.Record
	p.SetExpand(e)
}

func (p *Competition) Seeds() []*Team {
	rels := p.ExpandedAll("seeds")
	proxies := make([]*Team, len(rels))
	for i := range len(rels) {
		proxies[i] = &Team{}
		proxies[i].Record = rels[i]
	}
	return proxies
}

func (p *Competition) SetSeeds(seeds []*Team) {
	records := make([]*core.Record, len(seeds))
	for i, r := range seeds {
		records[i] = r.Record
	}
	e := p.Expand()
	e["seeds"] = records
	p.SetExpand(e)
}

func (p *Competition) Draw() []*Team {
	rels := p.ExpandedAll("draw")
	proxies := make([]*Team, len(rels))
	for i := range len(rels) {
		proxies[i] = &Team{}
		proxies[i].Record = rels[i]
	}
	return proxies
}

func (p *Competition) SetDraw(draw []*Team) {
	records := make([]*core.Record, len(draw))
	for i, r := range draw {
		records[i] = r.Record
	}
	e := p.Expand()
	e["draw"] = records
	p.SetExpand(e)
}

func (p *Competition) Matches() []*MatchData {
	rels := p.ExpandedAll("matches")
	proxies := make([]*MatchData, len(rels))
	for i := range len(rels) {
		proxies[i] = &MatchData{}
		proxies[i].Record = rels[i]
	}
	return proxies
}

func (p *Competition) SetMatches(matches []*MatchData) {
	records := make([]*core.Record, len(matches))
	for i, r := range matches {
		records[i] = r.Record
	}
	e := p.Expand()
	e["matches"] = records
	p.SetExpand(e)
}

func (p *Competition) TieBreakers() []*TieBreaker {
	rels := p.ExpandedAll("tieBreakers")
	proxies := make([]*TieBreaker, len(rels))
	for i := range len(rels) {
		proxies[i] = &TieBreaker{}
		proxies[i].Record = rels[i]
	}
	return proxies
}

func (p *Competition) SetTieBreakers(tieBreakers []*TieBreaker) {
	records := make([]*core.Record, len(tieBreakers))
	for i, r := range tieBreakers {
		records[i] = r.Record
	}
	e := p.Expand()
	e["tieBreakers"] = records
	p.SetExpand(e)
}

func (p *Competition) RngSeed() float64 {
	return p.GetFloat("rngSeed")
}

func (p *Competition) SetRngSeed(rngSeed float64) {
	p.Set("rngSeed", rngSeed)
}

func (p *Competition) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Competition) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Competition) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Competition) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type Team struct {
	core.BaseRecordProxy
}

func (p *Team) Players() []*Player {
	rels := p.ExpandedAll("players")
	proxies := make([]*Player, len(rels))
	for i := range len(rels) {
		proxies[i] = &Player{}
		proxies[i].Record = rels[i]
	}
	return proxies
}

func (p *Team) SetPlayers(players []*Player) {
	records := make([]*core.Record, len(players))
	for i, r := range players {
		records[i] = r.Record
	}
	e := p.Expand()
	e["players"] = records
	p.SetExpand(e)
}

func (p *Team) Resigned() bool {
	return p.GetBool("resigned")
}

func (p *Team) SetResigned(resigned bool) {
	p.Set("resigned", resigned)
}

func (p *Team) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Team) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Team) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Team) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type Gymnasium struct {
	core.BaseRecordProxy
}

func (p *Gymnasium) Name() string {
	return p.GetString("name")
}

func (p *Gymnasium) SetName(name string) {
	p.Set("name", name)
}

func (p *Gymnasium) Directions() string {
	return p.GetString("directions")
}

func (p *Gymnasium) SetDirections(directions string) {
	p.Set("directions", directions)
}

func (p *Gymnasium) Rows() float64 {
	return p.GetFloat("rows")
}

func (p *Gymnasium) SetRows(rows float64) {
	p.Set("rows", rows)
}

func (p *Gymnasium) Columns() float64 {
	return p.GetFloat("columns")
}

func (p *Gymnasium) SetColumns(columns float64) {
	p.Set("columns", columns)
}

func (p *Gymnasium) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Gymnasium) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Gymnasium) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Gymnasium) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type Court struct {
	core.BaseRecordProxy
}

func (p *Court) Gymnasium() *Gymnasium {
	var proxy *Gymnasium
	if rel := p.ExpandedOne("gymnasium"); rel != nil {
		proxy = &Gymnasium{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Court) SetGymnasium(gymnasium *Gymnasium) {
	e := p.Expand()
	e["gymnasium"] = gymnasium.Record
	p.SetExpand(e)
}

func (p *Court) Name() string {
	return p.GetString("name")
}

func (p *Court) SetName(name string) {
	p.Set("name", name)
}

func (p *Court) PositionX() float64 {
	return p.GetFloat("positionX")
}

func (p *Court) SetPositionX(positionX float64) {
	p.Set("positionX", positionX)
}

func (p *Court) PositionY() float64 {
	return p.GetFloat("positionY")
}

func (p *Court) SetPositionY(positionY float64) {
	p.Set("positionY", positionY)
}

func (p *Court) IsActive() bool {
	return p.GetBool("isActive")
}

func (p *Court) SetIsActive(isActive bool) {
	p.Set("isActive", isActive)
}

func (p *Court) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Court) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Court) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Court) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type MatchData struct {
	core.BaseRecordProxy
}

func (p *MatchData) Sets() []*MatchSet {
	rels := p.ExpandedAll("sets")
	proxies := make([]*MatchSet, len(rels))
	for i := range len(rels) {
		proxies[i] = &MatchSet{}
		proxies[i].Record = rels[i]
	}
	return proxies
}

func (p *MatchData) SetSets(sets []*MatchSet) {
	records := make([]*core.Record, len(sets))
	for i, r := range sets {
		records[i] = r.Record
	}
	e := p.Expand()
	e["sets"] = records
	p.SetExpand(e)
}

func (p *MatchData) Court() *Court {
	var proxy *Court
	if rel := p.ExpandedOne("court"); rel != nil {
		proxy = &Court{}
		proxy.Record = rel
	}
	return proxy
}

func (p *MatchData) SetCourt(court *Court) {
	e := p.Expand()
	e["court"] = court.Record
	p.SetExpand(e)
}

func (p *MatchData) WithdrawnTeams() []*Team {
	rels := p.ExpandedAll("withdrawnTeams")
	proxies := make([]*Team, len(rels))
	for i := range len(rels) {
		proxies[i] = &Team{}
		proxies[i].Record = rels[i]
	}
	return proxies
}

func (p *MatchData) SetWithdrawnTeams(withdrawnTeams []*Team) {
	records := make([]*core.Record, len(withdrawnTeams))
	for i, r := range withdrawnTeams {
		records[i] = r.Record
	}
	e := p.Expand()
	e["withdrawnTeams"] = records
	p.SetExpand(e)
}

func (p *MatchData) StartTime() types.DateTime {
	return p.GetDateTime("startTime")
}

func (p *MatchData) SetStartTime(startTime types.DateTime) {
	p.Set("startTime", startTime)
}

func (p *MatchData) CourtAssignmentTime() types.DateTime {
	return p.GetDateTime("courtAssignmentTime")
}

func (p *MatchData) SetCourtAssignmentTime(courtAssignmentTime types.DateTime) {
	p.Set("courtAssignmentTime", courtAssignmentTime)
}

func (p *MatchData) EndTime() types.DateTime {
	return p.GetDateTime("endTime")
}

func (p *MatchData) SetEndTime(endTime types.DateTime) {
	p.Set("endTime", endTime)
}

func (p *MatchData) ResultCard() string {
	return p.GetString("resultCard")
}

func (p *MatchData) SetResultCard(resultCard string) {
	p.Set("resultCard", resultCard)
}

func (p *MatchData) GameSheetPrinted() bool {
	return p.GetBool("gameSheetPrinted")
}

func (p *MatchData) SetGameSheetPrinted(gameSheetPrinted bool) {
	p.Set("gameSheetPrinted", gameSheetPrinted)
}

func (p *MatchData) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *MatchData) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *MatchData) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *MatchData) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type MatchSet struct {
	core.BaseRecordProxy
}

func (p *MatchSet) Team1Points() float64 {
	return p.GetFloat("team1Points")
}

func (p *MatchSet) SetTeam1Points(team1Points float64) {
	p.Set("team1Points", team1Points)
}

func (p *MatchSet) Team2Points() float64 {
	return p.GetFloat("team2Points")
}

func (p *MatchSet) SetTeam2Points(team2Points float64) {
	p.Set("team2Points", team2Points)
}

func (p *MatchSet) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *MatchSet) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *MatchSet) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *MatchSet) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type TournamentOrganizer struct {
	core.BaseRecordProxy
}

func (p *TournamentOrganizer) Username() string {
	return p.GetString("username")
}

func (p *TournamentOrganizer) SetUsername(username string) {
	p.Set("username", username)
}

func (p *TournamentOrganizer) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *TournamentOrganizer) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *TournamentOrganizer) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *TournamentOrganizer) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type AgeGroupType int

const (
	Over AgeGroupType = iota
	Under
)

var zzAgeGroupTypeSelectNameMap = map[string]AgeGroupType{"over": 0, "under": 1}
var zzAgeGroupTypeSelectIotaMap = map[AgeGroupType]string{0: "over", 1: "under"}

type AgeGroup struct {
	core.BaseRecordProxy
}

func (p *AgeGroup) Age() float64 {
	return p.GetFloat("age")
}

func (p *AgeGroup) SetAge(age float64) {
	p.Set("age", age)
}

func (p *AgeGroup) Type() AgeGroupType {
	option := p.GetString("type")
	i, ok := zzAgeGroupTypeSelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *AgeGroup) SetType(type_ AgeGroupType) {
	i, ok := zzAgeGroupTypeSelectIotaMap[type_]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("type", i)
}

func (p *AgeGroup) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *AgeGroup) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *AgeGroup) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *AgeGroup) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type QueueMode int

const (
	Manual QueueMode = iota
	AutoCourtAssignment
	Auto
)

var zzQueueModeSelectNameMap = map[string]QueueMode{"manual": 0, "autoCourtAssignment": 1, "auto": 2}
var zzQueueModeSelectIotaMap = map[QueueMode]string{0: "manual", 1: "autoCourtAssignment", 2: "auto"}

type Tournament struct {
	core.BaseRecordProxy
}

func (p *Tournament) Title() string {
	return p.GetString("title")
}

func (p *Tournament) SetTitle(title string) {
	p.Set("title", title)
}

func (p *Tournament) UseAgeGroups() bool {
	return p.GetBool("useAgeGroups")
}

func (p *Tournament) SetUseAgeGroups(useAgeGroups bool) {
	p.Set("useAgeGroups", useAgeGroups)
}

func (p *Tournament) UsePlayingLevels() bool {
	return p.GetBool("usePlayingLevels")
}

func (p *Tournament) SetUsePlayingLevels(usePlayingLevels bool) {
	p.Set("usePlayingLevels", usePlayingLevels)
}

func (p *Tournament) DontReprintGameSheets() bool {
	return p.GetBool("dontReprintGameSheets")
}

func (p *Tournament) SetDontReprintGameSheets(dontReprintGameSheets bool) {
	p.Set("dontReprintGameSheets", dontReprintGameSheets)
}

func (p *Tournament) PrintQrCodes() bool {
	return p.GetBool("printQrCodes")
}

func (p *Tournament) SetPrintQrCodes(printQrCodes bool) {
	p.Set("printQrCodes", printQrCodes)
}

func (p *Tournament) PlayerRestTime() float64 {
	return p.GetFloat("playerRestTime")
}

func (p *Tournament) SetPlayerRestTime(playerRestTime float64) {
	p.Set("playerRestTime", playerRestTime)
}

func (p *Tournament) QueueMode() QueueMode {
	option := p.GetString("queueMode")
	i, ok := zzQueueModeSelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *Tournament) SetQueueMode(queueMode QueueMode) {
	i, ok := zzQueueModeSelectIotaMap[queueMode]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("queueMode", i)
}

func (p *Tournament) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Tournament) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Tournament) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Tournament) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type TournamentType int

const (
	RoundRobin TournamentType = iota
	SingleElimination
	GroupKnockout
	DoubleElimination
	SingleEliminationWithConsolation
)

var zzTournamentTypeSelectNameMap = map[string]TournamentType{"RoundRobin": 0, "SingleElimination": 1, "GroupKnockout": 2, "DoubleElimination": 3, "SingleEliminationWithConsolation": 4}
var zzTournamentTypeSelectIotaMap = map[TournamentType]string{0: "RoundRobin", 1: "SingleElimination", 2: "GroupKnockout", 3: "DoubleElimination", 4: "SingleEliminationWithConsolation"}

type SeedingMode int

const (
	RandomSeeds SeedingMode = iota
	SingleSeeds
	TieredSeeds
)

var zzSeedingModeSelectNameMap = map[string]SeedingMode{"random": 0, "single": 1, "tiered": 2}
var zzSeedingModeSelectIotaMap = map[SeedingMode]string{0: "random", 1: "single", 2: "tiered"}

type KnockOutMode int

const (
	Single KnockOutMode = iota
	Double
	Consolation
)

var zzKnockOutModeSelectNameMap = map[string]KnockOutMode{"single": 0, "double": 1, "consolation": 2}
var zzKnockOutModeSelectIotaMap = map[KnockOutMode]string{0: "single", 1: "double", 2: "consolation"}

type TournamentModeSettings struct {
	core.BaseRecordProxy
}

func (p *TournamentModeSettings) Type() TournamentType {
	option := p.GetString("type")
	i, ok := zzTournamentTypeSelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *TournamentModeSettings) SetType(type_ TournamentType) {
	i, ok := zzTournamentTypeSelectIotaMap[type_]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("type", i)
}

func (p *TournamentModeSettings) SeedingMode() SeedingMode {
	option := p.GetString("seedingMode")
	i, ok := zzSeedingModeSelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *TournamentModeSettings) SetSeedingMode(seedingMode SeedingMode) {
	i, ok := zzSeedingModeSelectIotaMap[seedingMode]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("seedingMode", i)
}

func (p *TournamentModeSettings) KnockOutMode() KnockOutMode {
	option := p.GetString("knockOutMode")
	i, ok := zzKnockOutModeSelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *TournamentModeSettings) SetKnockOutMode(knockOutMode KnockOutMode) {
	i, ok := zzKnockOutModeSelectIotaMap[knockOutMode]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("knockOutMode", i)
}

func (p *TournamentModeSettings) Passes() float64 {
	return p.GetFloat("passes")
}

func (p *TournamentModeSettings) SetPasses(passes float64) {
	p.Set("passes", passes)
}

func (p *TournamentModeSettings) NumGroups() float64 {
	return p.GetFloat("numGroups")
}

func (p *TournamentModeSettings) SetNumGroups(numGroups float64) {
	p.Set("numGroups", numGroups)
}

func (p *TournamentModeSettings) NumQualifications() float64 {
	return p.GetFloat("numQualifications")
}

func (p *TournamentModeSettings) SetNumQualifications(numQualifications float64) {
	p.Set("numQualifications", numQualifications)
}

func (p *TournamentModeSettings) NumConsolationRounds() float64 {
	return p.GetFloat("numConsolationRounds")
}

func (p *TournamentModeSettings) SetNumConsolationRounds(numConsolationRounds float64) {
	p.Set("numConsolationRounds", numConsolationRounds)
}

func (p *TournamentModeSettings) PlacesToPlayOut() float64 {
	return p.GetFloat("placesToPlayOut")
}

func (p *TournamentModeSettings) SetPlacesToPlayOut(placesToPlayOut float64) {
	p.Set("placesToPlayOut", placesToPlayOut)
}

func (p *TournamentModeSettings) WinningPoints() float64 {
	return p.GetFloat("winningPoints")
}

func (p *TournamentModeSettings) SetWinningPoints(winningPoints float64) {
	p.Set("winningPoints", winningPoints)
}

func (p *TournamentModeSettings) WinningSets() float64 {
	return p.GetFloat("winningSets")
}

func (p *TournamentModeSettings) SetWinningSets(winningSets float64) {
	p.Set("winningSets", winningSets)
}

func (p *TournamentModeSettings) MaxPoints() float64 {
	return p.GetFloat("maxPoints")
}

func (p *TournamentModeSettings) SetMaxPoints(maxPoints float64) {
	p.Set("maxPoints", maxPoints)
}

func (p *TournamentModeSettings) TwoPointMargin() bool {
	return p.GetBool("twoPointMargin")
}

func (p *TournamentModeSettings) SetTwoPointMargin(twoPointMargin bool) {
	p.Set("twoPointMargin", twoPointMargin)
}

func (p *TournamentModeSettings) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *TournamentModeSettings) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *TournamentModeSettings) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *TournamentModeSettings) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type TieBreaker struct {
	core.BaseRecordProxy
}

func (p *TieBreaker) TieBreakerRanking() []*Team {
	rels := p.ExpandedAll("tieBreakerRanking")
	proxies := make([]*Team, len(rels))
	for i := range len(rels) {
		proxies[i] = &Team{}
		proxies[i].Record = rels[i]
	}
	return proxies
}

func (p *TieBreaker) SetTieBreakerRanking(tieBreakerRanking []*Team) {
	records := make([]*core.Record, len(tieBreakerRanking))
	for i, r := range tieBreakerRanking {
		records[i] = r.Record
	}
	e := p.Expand()
	e["tieBreakerRanking"] = records
	p.SetExpand(e)
}

func (p *TieBreaker) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *TieBreaker) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *TieBreaker) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *TieBreaker) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}
